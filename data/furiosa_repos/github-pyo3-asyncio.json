{
  "name": "pyo3-asyncio",
  "url": "https://github.com/furiosa-ai/pyo3-asyncio",
  "visibility": "public",
  "readme": {
    "title": "PyO3 Asyncio",
    "sections": [
      {
        "heading": "PyO3 Asyncio",
        "text": "Rust\nbindings for\nPython\n's\nAsyncio Library\n. This crate facilitates interactions between Rust Futures and Python Coroutines and manages the lifecycle of their corresponding event loops.\nPyO3 Project:\nHomepage\n|\nGitHub\nPyO3 Asyncio API Documentation:\nstable\n|\nmaster\nGuide for Async / Await\nstable\n|\nmain\nContributing Notes:\ngithub\nPyO3 Asyncio is a\nbrand new\npart of the broader PyO3 ecosystem. Feel free to open any issues for feature requests or bugfixes for this crate.\nIf you're a new-comer, the best way to get started is to read through the primer below! For\nv0.13\nand\nv0.14\nusers I highly recommend reading through the\nmigration section\nto get a general idea of what's changed in\nv0.14\nand\nv0.15\n.",
        "children": [
          {
            "heading": "Usage",
            "text": "Like PyO3, PyO3 Asyncio supports the following software versions:\nPython 3.7 and up (CPython and PyPy)\nRust 1.48 and up",
            "children": []
          },
          {
            "heading": "PyO3 Asyncio Primer",
            "text": "If you are working with a Python library that makes use of async functions or wish to provide\nPython bindings for an async Rust library,\npyo3-asyncio\nlikely has the tools you need. It provides conversions between async functions in both Python and\nRust and was designed with first-class support for popular Rust runtimes such as\ntokio\nand\nasync-std\n. In addition, all async Python\ncode runs on the default\nasyncio\nevent loop, so\npyo3-asyncio\nshould work just fine with existing\nPython libraries.\nIn the following sections, we'll give a general overview of\npyo3-asyncio\nexplaining how to call\nasync Python functions with PyO3, how to call async Rust functions from Python, and how to configure\nyour codebase to manage the runtimes of both.",
            "children": [
              {
                "heading": "Quickstart",
                "text": "Here are some examples to get you started right away! A more detailed breakdown\nof the concepts in these examples can be found in the following sections.",
                "children": [
                  {
                    "heading": "Rust Applications",
                    "text": "Here we initialize the runtime, import Python's\nasyncio\nlibrary and run the given future to completion using Python's default\nEventLoop\nand\nasync-std\n. Inside the future, we convert\nasyncio\nsleep into a Rust future and await it.\n#\nCargo.toml dependencies\n[\ndependencies\n]\npyo3\n= {\nversion\n=\n\"\n0.18\n\"\n}\npyo3-asyncio\n= {\nversion\n=\n\"\n0.18\n\"\n,\nfeatures\n= [\n\"\nattributes\n\"\n,\n\"\nasync-std-runtime\n\"\n] }\nasync-std\n=\n\"\n1.9\n\"\n//! main.rs\nuse\npyo3\n::\nprelude\n::\n*\n;\n#\n[\npyo3_asyncio\n::\nasync_std\n::\nmain\n]\nasync\nfn\nmain\n(\n)\n->\nPyResult\n<\n(\n)\n>\n{\nlet\nfut =\nPython\n::\nwith_gil\n(\n|py|\n{\nlet\nasyncio = py\n.\nimport\n(\n\"asyncio\"\n)\n?\n;\n// convert asyncio.sleep into a Rust Future\npyo3_asyncio\n::\nasync_std\n::\ninto_future\n(\nasyncio\n.\ncall_method1\n(\n\"sleep\"\n,\n(\n1\n.\ninto_py\n(\npy\n)\n,\n)\n)\n?\n)\n}\n)\n?\n;\nfut\n.\nawait\n?\n;\nOk\n(\n(\n)\n)\n}\nThe same application can be written to use\ntokio\ninstead using the\n#[pyo3_asyncio::tokio::main]\nattribute.\n#\nCargo.toml dependencies\n[\ndependencies\n]\npyo3\n= {\nversion\n=\n\"\n0.18\n\"\n}\npyo3-asyncio\n= {\nversion\n=\n\"\n0.18\n\"\n,\nfeatures\n= [\n\"\nattributes\n\"\n,\n\"\ntokio-runtime\n\"\n] }\ntokio\n=\n\"\n1.9\n\"\n//! main.rs\nuse\npyo3\n::\nprelude\n::\n*\n;\n#\n[\npyo3_asyncio\n::\ntokio\n::\nmain\n]\nasync\nfn\nmain\n(\n)\n->\nPyResult\n<\n(\n)\n>\n{\nlet\nfut =\nPython\n::\nwith_gil\n(\n|py|\n{\nlet\nasyncio = py\n.\nimport\n(\n\"asyncio\"\n)\n?\n;\n// convert asyncio.sleep into a Rust Future\npyo3_asyncio\n::\ntokio\n::\ninto_future\n(\nasyncio\n.\ncall_method1\n(\n\"sleep\"\n,\n(\n1\n.\ninto_py\n(\npy\n)\n,\n)\n)\n?\n)\n}\n)\n?\n;\nfut\n.\nawait\n?\n;\nOk\n(\n(\n)\n)\n}\nMore details on the usage of this library can be found in the\nAPI docs\nand the primer below.",
                    "children": []
                  },
                  {
                    "heading": "PyO3 Native Rust Modules",
                    "text": "PyO3 Asyncio can also be used to write native modules with async functions.\nAdd the\n[lib]\nsection to\nCargo.toml\nto make your library a\ncdylib\nthat Python can import.\n[\nlib\n]\nname\n=\n\"\nmy_async_module\n\"\ncrate-type\n= [\n\"\ncdylib\n\"\n]\nMake your project depend on\npyo3\nwith the\nextension-module\nfeature enabled and select your\npyo3-asyncio\nruntime:\nFor\nasync-std\n:\n[\ndependencies\n]\npyo3\n= {\nversion\n=\n\"\n0.18\n\"\n,\nfeatures\n= [\n\"\nextension-module\n\"\n] }\npyo3-asyncio\n= {\nversion\n=\n\"\n0.18\n\"\n,\nfeatures\n= [\n\"\nasync-std-runtime\n\"\n] }\nasync-std\n=\n\"\n1.9\n\"\nFor\ntokio\n:\n[\ndependencies\n]\npyo3\n= {\nversion\n=\n\"\n0.18\n\"\n,\nfeatures\n= [\n\"\nextension-module\n\"\n] }\npyo3-asyncio\n= {\nversion\n=\n\"\n0.18\n\"\n,\nfeatures\n= [\n\"\ntokio-runtime\n\"\n] }\ntokio\n=\n\"\n1.9\n\"\nExport an async function that makes use of\nasync-std\n:\n//! lib.rs\nuse\npyo3\n::\n{\nprelude\n::\n*\n,\nwrap_pyfunction\n}\n;\n#\n[\npyfunction\n]\nfn\nrust_sleep\n(\npy\n:\nPython\n)\n->\nPyResult\n<\n&\nPyAny\n>\n{\npyo3_asyncio\n::\nasync_std\n::\nfuture_into_py\n(\npy\n,\nasync\n{\nasync_std\n::\ntask\n::\nsleep\n(\nstd\n::\ntime\n::\nDuration\n::\nfrom_secs\n(\n1\n)\n)\n.\nawait\n;\nOk\n(\n(\n)\n)\n}\n)\n}\n#\n[\npymodule\n]\nfn\nmy_async_module\n(\npy\n:\nPython\n,\nm\n:\n&\nPyModule\n)\n->\nPyResult\n<\n(\n)\n>\n{\nm\n.\nadd_function\n(\nwrap_pyfunction\n!\n(\nrust_sleep\n,\nm\n)\n?\n)\n?\n;\nOk\n(\n(\n)\n)\n}\nIf you want to use\ntokio\ninstead, here's what your module should look like:\n//! lib.rs\nuse\npyo3\n::\n{\nprelude\n::\n*\n,\nwrap_pyfunction\n}\n;\n#\n[\npyfunction\n]\nfn\nrust_sleep\n(\npy\n:\nPython\n)\n->\nPyResult\n<\n&\nPyAny\n>\n{\npyo3_asyncio\n::\ntokio\n::\nfuture_into_py\n(\npy\n,\nasync\n{\ntokio\n::\ntime\n::\nsleep\n(\nstd\n::\ntime\n::\nDuration\n::\nfrom_secs\n(\n1\n)\n)\n.\nawait\n;\nOk\n(\n(\n)\n)\n}\n)\n}\n#\n[\npymodule\n]\nfn\nmy_async_module\n(\npy\n:\nPython\n,\nm\n:\n&\nPyModule\n)\n->\nPyResult\n<\n(\n)\n>\n{\nm\n.\nadd_function\n(\nwrap_pyfunction\n!\n(\nrust_sleep\n,\nm\n)\n?\n)\n?\n;\nOk\n(\n(\n)\n)\n}\nYou can build your module with maturin (see the\nUsing Rust in Python\nsection in the PyO3 guide for setup instructions). After that you should be able to run the Python REPL to try it out.\nmaturin develop\n&&\npython3\nðŸ”— Found pyo3 bindings\nðŸ Found CPython 3.8 at python3\n    Finished dev [unoptimized + debuginfo] target(s)\nin\n0.04s\nPython 3.8.5 (default, Jan 27 2021, 15:41:15)\n[GCC 9.3.0] on linux\nType\n\"\nhelp\n\"\n,\n\"\ncopyright\n\"\n,\n\"\ncredits\n\"\nor\n\"\nlicense\n\"\nfor\nmore information.\n>>> import asyncio\n>>>\n>>> from my_async_module import rust_sleep\n>>>\n>>> async def\nmain\n():\n>>>     await\nrust_sleep\n()\n>>>\n>>>\n#\nshould sleep for 1s\n>>>\nasyncio.run(main\n())\n>>>",
                    "children": []
                  }
                ]
              },
              {
                "heading": "Awaiting an Async Python Function in Rust",
                "text": "Let's take a look at a dead simple async Python function:\n# Sleep for 1 second\nasync\ndef\npy_sleep\n():\nawait\nasyncio\n.\nsleep\n(\n1\n)\nAsync functions in Python are simply functions that return a\ncoroutine\nobject\n. For our purposes,\nwe really don't need to know much about these\ncoroutine\nobjects. The key factor here is that calling\nan\nasync\nfunction is\njust like calling a regular function\n, the only difference is that we have\nto do something special with the object that it returns.\nNormally in Python, that something special is the\nawait\nkeyword, but in order to await this\ncoroutine in Rust, we first need to convert it into Rust's version of a\ncoroutine\n: a\nFuture\n.\nThat's where\npyo3-asyncio\ncomes in.\npyo3_asyncio::into_future\nperforms this conversion for us:\nuse\npyo3\n::\nprelude\n::\n*\n;\n#\n[\npyo3_asyncio\n::\ntokio\n::\nmain\n]\nasync\nfn\nmain\n(\n)\n->\nPyResult\n<\n(\n)\n>\n{\nlet\nfuture =\nPython\n::\nwith_gil\n(\n|py| ->\nPyResult\n<\n_\n>\n{\n// import the module containing the py_sleep function\nlet\nexample = py\n.\nimport\n(\n\"example\"\n)\n?\n;\n// calling the py_sleep method like a normal function\n// returns a coroutine\nlet\ncoroutine = example\n.\ncall_method0\n(\n\"py_sleep\"\n)\n?\n;\n// convert the coroutine into a Rust future using the\n// tokio runtime\npyo3_asyncio\n::\ntokio\n::\ninto_future\n(\ncoroutine\n)\n}\n)\n?\n;\n// await the future\nfuture\n.\nawait\n?\n;\nOk\n(\n(\n)\n)\n}\nIf you're interested in learning more about\ncoroutines\nand\nawaitables\nin general, check out the\nPython 3\nasyncio\ndocs\nfor more information.",
                "children": []
              },
              {
                "heading": "Awaiting a Rust Future in Python",
                "text": "Here we have the same async function as before written in Rust using the\nasync-std\nruntime:\n/// Sleep for 1 second\nasync\nfn\nrust_sleep\n(\n)\n{\nasync_std\n::\ntask\n::\nsleep\n(\nstd\n::\ntime\n::\nDuration\n::\nfrom_secs\n(\n1\n)\n)\n.\nawait\n;\n}\nSimilar to Python, Rust's async functions also return a special object called a\nFuture\n:\nlet\nfuture =\nrust_sleep\n(\n)\n;\nWe can convert this\nFuture\nobject into Python to make it\nawaitable\n. This tells Python that you\ncan use the\nawait\nkeyword with it. In order to do this, we'll call\npyo3_asyncio::async_std::future_into_py\n:\nuse\npyo3\n::\nprelude\n::\n*\n;\nasync\nfn\nrust_sleep\n(\n)\n{\nasync_std\n::\ntask\n::\nsleep\n(\nstd\n::\ntime\n::\nDuration\n::\nfrom_secs\n(\n1\n)\n)\n.\nawait\n;\n}\n#\n[\npyfunction\n]\nfn\ncall_rust_sleep\n(\npy\n:\nPython\n)\n->\nPyResult\n<\n&\nPyAny\n>\n{\npyo3_asyncio\n::\nasync_std\n::\nfuture_into_py\n(\npy\n,\nasync\nmove\n{\nrust_sleep\n(\n)\n.\nawait\n;\nOk\n(\n(\n)\n)\n}\n)\n}\nIn Python, we can call this pyo3 function just like any other async function:\nfrom\nexample\nimport\ncall_rust_sleep\nasync\ndef\nrust_sleep\n():\nawait\ncall_rust_sleep\n()",
                "children": []
              }
            ]
          },
          {
            "heading": "Managing Event Loops",
            "text": "Python's event loop requires some special treatment, especially regarding the main thread. Some of\nPython's\nasyncio\nfeatures, like proper signal handling, require control over the main thread, which\ndoesn't always play well with Rust.\nLuckily, Rust's event loops are pretty flexible and don't\nneed\ncontrol over the main thread, so in\npyo3-asyncio\n, we decided the best way to handle Rust/Python interop was to just surrender the main\nthread to Python and run Rust's event loops in the background. Unfortunately, since most event loop\nimplementations\nprefer\ncontrol over the main thread, this can still make some things awkward.",
            "children": [
              {
                "heading": "PyO3 Asyncio Initialization",
                "text": "Because Python needs to control the main thread, we can't use the convenient proc macros from Rust\nruntimes to handle the\nmain\nfunction or\n#[test]\nfunctions. Instead, the initialization for PyO3 has to be done from the\nmain\nfunction and the main\nthread must block on\npyo3_asyncio::run_forever\nor\npyo3_asyncio::async_std::run_until_complete\n.\nBecause we have to block on one of those functions, we can't use\n#[async_std::main]\nor\n#[tokio::main]\nsince it's not a good idea to make long blocking calls during an async function.\nInternally, these\n#[main]\nproc macros are expanded to something like this:\nfn\nmain\n(\n)\n{\n// your async main fn\nasync\nfn\n_main_impl\n(\n)\n{\n/* ... */\n}\nRuntime\n::\nnew\n(\n)\n.\nblock_on\n(\n_main_impl\n(\n)\n)\n;\n}\nMaking a long blocking call inside the\nFuture\nthat's being driven by\nblock_on\nprevents that\nthread from doing anything else and can spell trouble for some runtimes (also this will actually\ndeadlock a single-threaded runtime!). Many runtimes have some sort of\nspawn_blocking\nmechanism\nthat can avoid this problem, but again that's not something we can use here since we need it to\nblock on the\nmain\nthread.\nFor this reason,\npyo3-asyncio\nprovides its own set of proc macros to provide you with this\ninitialization. These macros are intended to mirror the initialization of\nasync-std\nand\ntokio\nwhile also satisfying the Python runtime's needs.\nHere's a full example of PyO3 initialization with the\nasync-std\nruntime:\nuse\npyo3\n::\nprelude\n::\n*\n;\n#\n[\npyo3_asyncio\n::\nasync_std\n::\nmain\n]\nasync\nfn\nmain\n(\n)\n->\nPyResult\n<\n(\n)\n>\n{\n// PyO3 is initialized - Ready to go\nlet\nfut =\nPython\n::\nwith_gil\n(\n|py| ->\nPyResult\n<\n_\n>\n{\nlet\nasyncio = py\n.\nimport\n(\n\"asyncio\"\n)\n?\n;\n// convert asyncio.sleep into a Rust Future\npyo3_asyncio\n::\nasync_std\n::\ninto_future\n(\nasyncio\n.\ncall_method1\n(\n\"sleep\"\n,\n(\n1\n.\ninto_py\n(\npy\n)\n,\n)\n)\n?\n)\n}\n)\n?\n;\nfut\n.\nawait\n?\n;\nOk\n(\n(\n)\n)\n}",
                "children": [
                  {
                    "heading": "A Note About asyncio.run",
                    "text": "In Python 3.7+, the recommended way to run a top-level coroutine with\nasyncio\nis with\nasyncio.run\n. In\nv0.13\nwe recommended against using this function due to initialization issues, but in\nv0.14\nit's perfectly valid to use this function... with a caveat.\nSince our Rust <--> Python conversions require a reference to the Python event loop, this poses a problem. Imagine we have a PyO3 Asyncio module that defines\na\nrust_sleep\nfunction like in previous examples. You might rightfully assume that you can call pass this directly into\nasyncio.run\nlike this:\nimport\nasyncio\nfrom\nmy_async_module\nimport\nrust_sleep\nasyncio\n.\nrun\n(\nrust_sleep\n())\nYou might be surprised to find out that this throws an error:\nTraceback (most recent call last):\n  File\n\"\nexample.py\n\"\n, line 5,\nin\n<\nmodule\n>\nasyncio.run(rust_sleep\n())\nRuntimeError: no running event loop\nWhat's happening here is that we are calling\nrust_sleep\nbefore\nthe future is\nactually running on the event loop created by\nasyncio.run\n. This is counter-intuitive, but expected behaviour, and unfortunately there doesn't seem to be a good way of solving this problem within PyO3 Asyncio itself.\nHowever, we can make this example work with a simple workaround:\nimport\nasyncio\nfrom\nmy_async_module\nimport\nrust_sleep\n# Calling main will just construct the coroutine that later calls rust_sleep.\n# - This ensures that rust_sleep will be called when the event loop is running,\n#   not before.\nasync\ndef\nmain\n():\nawait\nrust_sleep\n()\n# Run the main() coroutine at the top-level instead\nasyncio\n.\nrun\n(\nmain\n())",
                    "children": []
                  },
                  {
                    "heading": "Non-standard Python Event Loops",
                    "text": "Python allows you to use alternatives to the default\nasyncio\nevent loop. One\npopular alternative is\nuvloop\n. In\nv0.13\nusing non-standard event loops was\na bit of an ordeal, but in\nv0.14\nit's trivial.",
                    "children": []
                  },
                  {
                    "heading": "Using uvloop in a PyO3 Asyncio Native Extensions",
                    "text": "#\nCargo.toml\n[\nlib\n]\nname\n=\n\"\nmy_async_module\n\"\ncrate-type\n= [\n\"\ncdylib\n\"\n]\n\n[\ndependencies\n]\npyo3\n= {\nversion\n=\n\"\n0.18\n\"\n,\nfeatures\n= [\n\"\nextension-module\n\"\n] }\npyo3-asyncio\n= {\nversion\n=\n\"\n0.18\n\"\n,\nfeatures\n= [\n\"\ntokio-runtime\n\"\n] }\nasync-std\n=\n\"\n1.9\n\"\ntokio\n=\n\"\n1.9\n\"\n//! lib.rs\nuse\npyo3\n::\n{\nprelude\n::\n*\n,\nwrap_pyfunction\n}\n;\n#\n[\npyfunction\n]\nfn\nrust_sleep\n(\npy\n:\nPython\n)\n->\nPyResult\n<\n&\nPyAny\n>\n{\npyo3_asyncio\n::\ntokio\n::\nfuture_into_py\n(\npy\n,\nasync\n{\ntokio\n::\ntime\n::\nsleep\n(\nstd\n::\ntime\n::\nDuration\n::\nfrom_secs\n(\n1\n)\n)\n.\nawait\n;\nOk\n(\n(\n)\n)\n}\n)\n}\n#\n[\npymodule\n]\nfn\nmy_async_module\n(\n_py\n:\nPython\n,\nm\n:\n&\nPyModule\n)\n->\nPyResult\n<\n(\n)\n>\n{\nm\n.\nadd_function\n(\nwrap_pyfunction\n!\n(\nrust_sleep\n,\nm\n)\n?\n)\n?\n;\nOk\n(\n(\n)\n)\n}\n$ maturin develop\n&&\npython3\nðŸ”— Found pyo3 bindings\nðŸ Found CPython 3.8 at python3\n    Finished dev [unoptimized + debuginfo] target(s)\nin\n0.04s\nPython 3.8.8 (default, Apr 13 2021, 19:58:26)\n[GCC 7.3.0] :: Anaconda, Inc. on linux\nType\n\"\nhelp\n\"\n,\n\"\ncopyright\n\"\n,\n\"\ncredits\n\"\nor\n\"\nlicense\n\"\nfor\nmore information.\n>>> import asyncio\n>>> import uvloop\n>>>\n>>> import my_async_module\n>>>\n>>>\nuvloop.install\n()\n>>>\n>>> async def\nmain\n():\n...     await\nmy_async_module.rust_sleep\n()\n...\n>>>\nasyncio.run(main\n())\n>>>",
                    "children": []
                  },
                  {
                    "heading": "Using uvloop in Rust Applications",
                    "text": "Using\nuvloop\nin Rust applications is a bit trickier, but it's still possible\nwith relatively few modifications.\nUnfortunately, we can't make use of the\n#[pyo3_asyncio::<runtime>::main]\nattribute with non-standard event loops. This is because the\n#[pyo3_asyncio::<runtime>::main]\nproc macro has to interact with the Python\nevent loop before we can install the\nuvloop\npolicy.\n[\ndependencies\n]\nasync-std\n=\n\"\n1.9\n\"\npyo3\n=\n\"\n0.18\n\"\npyo3-asyncio\n= {\nversion\n=\n\"\n0.18\n\"\n,\nfeatures\n= [\n\"\nasync-std-runtime\n\"\n] }\n//! main.rs\nuse\npyo3\n::\n{\nprelude\n::\n*\n,\ntypes\n::\nPyType\n}\n;\nfn\nmain\n(\n)\n->\nPyResult\n<\n(\n)\n>\n{\npyo3\n::\nprepare_freethreaded_python\n(\n)\n;\nPython\n::\nwith_gil\n(\n|py|\n{\nlet\nuvloop = py\n.\nimport\n(\n\"uvloop\"\n)\n?\n;\nuvloop\n.\ncall_method0\n(\n\"install\"\n)\n?\n;\n// store a reference for the assertion\nlet\nuvloop =\nPyObject\n::\nfrom\n(\nuvloop\n)\n;\npyo3_asyncio\n::\nasync_std\n::\nrun\n(\npy\n,\nasync\nmove\n{\n// verify that we are on a uvloop.Loop\nPython\n::\nwith_gil\n(\n|py| ->\nPyResult\n<\n(\n)\n>\n{\nassert\n!\n(\nuvloop\n.\nas_ref\n(\npy\n)\n.\ngetattr\n(\n\"Loop\"\n)\n?\n.\ndowncast\n::\n<\nPyType\n>\n(\n)\n.\nunwrap\n(\n)\n.\nis_instance\n(\npyo3_asyncio\n::\nasync_std\n::\nget_current_loop\n(\npy\n)\n?\n)\n?\n)\n;\nOk\n(\n(\n)\n)\n}\n)\n?\n;\nasync_std\n::\ntask\n::\nsleep\n(\nstd\n::\ntime\n::\nDuration\n::\nfrom_secs\n(\n1\n)\n)\n.\nawait\n;\nOk\n(\n(\n)\n)\n}\n)\n}\n)\n}",
                    "children": []
                  }
                ]
              },
              {
                "heading": "Additional Information",
                "text": "Managing event loop references can be tricky with pyo3-asyncio. See\nEvent Loop References and ContextVars\nin the API docs to get a better intuition for how event loop references are managed in this library.\nTesting pyo3-asyncio libraries and applications requires a custom test harness since Python requires control over the main thread. You can find a testing guide in the\nAPI docs for the\ntesting\nmodule",
                "children": []
              }
            ]
          },
          {
            "heading": "Migration Guide",
            "text": "",
            "children": [
              {
                "heading": "Migrating from 0.13 to 0.14",
                "text": "So what's changed from\nv0.13\nto\nv0.14\n?\nWell, a lot actually. There were some pretty major flaws in the initialization behaviour of\nv0.13\n. While it would have been nicer to address these issues without changing the public API, I decided it'd be better to break some of the old API rather than completely change the underlying behaviour of the existing functions. I realize this is going to be a bit of a headache, so hopefully this section will help you through it.\nTo make things a bit easier, I decided to keep most of the old API alongside the new one (with some deprecation warnings to encourage users to move away from it). It should be possible to use the\nv0.13\nAPI alongside the newer\nv0.14\nAPI, which should allow you to upgrade your application piecemeal rather than all at once.\nBefore you get started, I personally recommend taking a look at\nEvent Loop References and ContextVars\nin order to get a better grasp on the motivation behind these changes and the nuance involved in using the new conversions.",
                "children": []
              },
              {
                "heading": "0.14 Highlights",
                "text": "Tokio initialization is now lazy.\nNo configuration necessary if you're using the multithreaded scheduler\nCalls to\npyo3_asyncio::tokio::init_multithread\nor\npyo3_asyncio::tokio::init_multithread_once\ncan just be removed.\nCalls to\npyo3_asyncio::tokio::init_current_thread\nor\npyo3_asyncio::tokio::init_current_thread_once\nrequire some special attention.\nCustom runtime configuration is done by passing a\ntokio::runtime::Builder\ninto\npyo3_asyncio::tokio::init\ninstead of a\ntokio::runtime::Runtime\nA new, more correct set of functions has been added to replace the\nv0.13\nconversions.\npyo3_asyncio::into_future_with_loop\npyo3_asyncio::<runtime>::future_into_py_with_loop\npyo3_asyncio::<runtime>::local_future_into_py_with_loop\npyo3_asyncio::<runtime>::into_future\npyo3_asyncio::<runtime>::future_into_py\npyo3_asyncio::<runtime>::local_future_into_py\npyo3_asyncio::<runtime>::get_current_loop\npyo3_asyncio::try_init\nis no longer required if you're only using\n0.14\nconversions\nThe\nThreadPoolExecutor\nis no longer configured automatically at the start.\nFortunately, this doesn't seem to have much effect on\nv0.13\ncode, it just means that it's now possible to configure the executor manually as you see fit.",
                "children": []
              },
              {
                "heading": "Upgrading Your Code to 0.14",
                "text": "Fix PyO3 0.14 initialization.\nPyO3 0.14 feature gated its automatic initialization behaviour behind \"auto-initialize\". You can either enable the \"auto-initialize\" behaviour in your project or add a call to\npyo3::prepare_freethreaded_python()\nto the start of your program.\nIf you're using the\n#[pyo3_asyncio::<runtime>::main]\nproc macro attributes, then you can skip this step.\n#[pyo3_asyncio::<runtime>::main]\nwill call\npyo3::prepare_freethreaded_python()\nat the start regardless of your project's \"auto-initialize\" feature.\nFix the tokio initialization.\nCalls to\npyo3_asyncio::tokio::init_multithread\nor\npyo3_asyncio::tokio::init_multithread_once\ncan just be removed.\nIf you're using the current thread scheduler, you'll need to manually spawn the thread that it runs on during initialization:\nlet\nmut\nbuilder = tokio\n::\nruntime\n::\nBuilder\n::\nnew_current_thread\n(\n)\n;\nbuilder\n.\nenable_all\n(\n)\n;\npyo3_asyncio\n::\ntokio\n::\ninit\n(\nbuilder\n)\n;\nstd\n::\nthread\n::\nspawn\n(\nmove\n||\n{\npyo3_asyncio\n::\ntokio\n::\nget_runtime\n(\n)\n.\nblock_on\n(\nfutures\n::\nfuture\n::\npending\n::\n<\n(\n)\n>\n(\n)\n)\n;\n}\n)\n;\nCustom\ntokio::runtime::Builder\nconfigs can be passed into\npyo3_asyncio::tokio::init\n. The\ntokio::runtime::Runtime\nwill be lazily instantiated on the first call to\npyo3_asyncio::tokio::get_runtime()\nIf you're using\npyo3_asyncio::run_forever\nin your application, you should switch to a more manual approach.\nrun_forever\nis not the recommended way of running an event loop in Python, so it might be a good idea to move away from it. This function would have needed to change for\n0.14\n, but since it's considered an edge case, it was decided that users could just manually call it if they need to.\nuse\npyo3\n::\nprelude\n::\n*\n;\nfn\nmain\n(\n)\n->\nPyResult\n<\n(\n)\n>\n{\npyo3\n::\nprepare_freethreaded_python\n(\n)\n;\nPython\n::\nwith_gil\n(\n|py|\n{\nlet\nasyncio = py\n.\nimport\n(\n\"asyncio\"\n)\n?\n;\nlet\nevent_loop = asyncio\n.\ncall_method0\n(\n\"new_event_loop\"\n)\n?\n;\nasyncio\n.\ncall_method1\n(\n\"set_event_loop\"\n,\n(\nevent_loop\n,\n)\n)\n?\n;\nlet\nevent_loop_hdl =\nPyObject\n::\nfrom\n(\nevent_loop\n)\n;\npyo3_asyncio\n::\ntokio\n::\nget_runtime\n(\n)\n.\nspawn\n(\nasync\nmove\n{\ntokio\n::\ntime\n::\nsleep\n(\nstd\n::\ntime\n::\nDuration\n::\nfrom_secs\n(\n1\n)\n)\n.\nawait\n;\n// Stop the event loop manually\nPython\n::\nwith_gil\n(\n|py|\n{\nevent_loop_hdl\n.\nas_ref\n(\npy\n)\n.\ncall_method1\n(\n\"call_soon_threadsafe\"\n,\n(\nevent_loop_hdl\n.\nas_ref\n(\npy\n)\n.\ngetattr\n(\n\"stop\"\n)\n.\nunwrap\n(\n)\n,\n)\n,\n)\n.\nunwrap\n(\n)\n;\n}\n)\n}\n)\n;\nevent_loop\n.\ncall_method0\n(\n\"run_forever\"\n)\n?\n;\nOk\n(\n(\n)\n)\n}\n)\n}\nReplace conversions with their newer counterparts.\nYou may encounter some issues regarding the usage of\nget_running_loop\nvs\nget_event_loop\n. For more details on these newer conversions and how they should be used see\nEvent Loop References and ContextVars\n.\nReplace\npyo3_asyncio::into_future\nwith\npyo3_asyncio::<runtime>::into_future\nReplace\npyo3_asyncio::<runtime>::into_coroutine\nwith\npyo3_asyncio::<runtime>::future_into_py\nReplace\npyo3_asyncio::get_event_loop\nwith\npyo3_asyncio::<runtime>::get_current_loop\nAfter all conversions have been replaced with their\nv0.14\ncounterparts,\npyo3_asyncio::try_init\ncan safely be removed.\nThe\nv0.13\nAPI has been removed in version\nv0.15",
                "children": []
              },
              {
                "heading": "Migrating from 0.14 to 0.15+",
                "text": "There have been a few changes to the API in order to support proper cancellation from Python and the\ncontextvars\nmodule.\nAny instance of\ncancellable_future_into_py\nand\nlocal_cancellable_future_into_py\nconversions can be replaced with their\nfuture_into_py\nand\nlocal_future_into_py\ncounterparts.\nCancellation support became the default behaviour in 0.15.\nInstances of\n*_with_loop\nconversions should be replaced with the newer\n*_with_locals\nconversions.\nuse\npyo3\n::\nprelude\n::\n*\n;\nPython\n::\nwith_gil\n(\n|py| ->\nPyResult\n<\n(\n)\n>\n{\n// *_with_loop conversions in 0.14\n//\n// let event_loop = pyo3_asyncio::get_running_loop(py)?;\n//\n// let fut = pyo3_asyncio::tokio::future_into_py_with_loop(\n//     event_loop,\n//     async move { Ok(Python::with_gil(|py| py.None())) }\n// )?;\n//\n// should be replaced with *_with_locals in 0.15+\nlet\nfut = pyo3_asyncio\n::\ntokio\n::\nfuture_into_py_with_locals\n(\npy\n,\npyo3_asyncio\n::\ntokio\n::\nget_current_locals\n(\npy\n)\n?\n,\nasync\nmove\n{\nOk\n(\n(\n)\n)\n}\n)\n?\n;\nOk\n(\n(\n)\n)\n}\n)\n;\nscope\nand\nscope_local\nvariants now accept\nTaskLocals\ninstead of\nevent_loop\n. You can usually just replace the\nevent_loop\nwith\npyo3_asyncio::TaskLocals::new(event_loop).copy_context(py)?\n.\nReturn types for\nfuture_into_py\n,\nfuture_into_py_with_locals\nlocal_future_into_py\n, and\nlocal_future_into_py_with_locals\nare now constrained by the bound\nIntoPy<PyObject>\ninstead of requiring the return type to be\nPyObject\n. This can make the return types for futures more flexible, but inference can also fail when the concrete type is ambiguous (for example when using\ninto()\n). Sometimes the\ninto()\ncan just be removed,\nrun\n, and\nrun_until_complete\ncan now return any\nSend + 'static\nvalue.",
                "children": []
              },
              {
                "heading": "Migrating from 0.15 to 0.16",
                "text": "Actually, not much has changed in the API. I'm happy to say that the PyO3 Asyncio is reaching a\npretty stable point in 0.16. For the most part, 0.16 has been about cleanup and removing deprecated\nfunctions from the API.\nPyO3 0.16 comes with a few API changes of its own, but one of the changes that most impacted PyO3\nAsyncio was it's decision to drop support for Python 3.6. PyO3 Asyncio has been using a few\nworkarounds / hacks to support the pre-3.7 version of Python's asyncio library that are no longer\nnecessary. PyO3 Asyncio's underlying implementation is now a bit cleaner because of this.\nPyO3 Asyncio 0.15 included some important fixes to the API in order to add support for proper task\ncancellation and allow for the preservation / use of contextvars in Python coroutines. This led to\nthe deprecation of some 0.14 functions that were used for edge cases in favor of some more correct\nversions, and those deprecated functions are now removed from the API in 0.16.\nIn addition, with PyO3 Asyncio 0.16, the library now has experimental support for conversions from\nPython's async generators into a Rust\nStream\n. There are currently two versions\nv1\nand\nv2\nwith\nslightly different performance and type signatures, so I'm hoping to get some feedback on which one\nworks best for downstream users. Just enable the\nunstable-streams\nfeature and you're good to go!\nThe inverse conversion, Rust\nStream\nto Python async generator, may come in a later release if\nrequested!",
                "children": []
              }
            ]
          }
        ]
      }
    ]
  },
  "metadata": {
    "description": null,
    "license": null,
    "stars": 0,
    "forks": 0,
    "topics": [],
    "last_updated": "2022-09-30T05:07:07.000Z"
  }
}