{
  "name": "maturin",
  "url": "https://github.com/furiosa-ai/maturin",
  "visibility": "public",
  "readme": {
    "title": "Maturin",
    "sections": [
      {
        "heading": "Maturin",
        "text": "formerly pyo3-pack\nBuild and publish crates with pyo3, rust-cpython, cffi and uniffi bindings as well as rust binaries as python packages.\nThis project is meant as a zero configuration replacement for\nsetuptools-rust\nand\nmilksnake\n.\nIt supports building wheels for python 3.5+ on windows, linux, mac and freebsd, can upload them to\npypi\nand has basic pypy support.\nCheck out the\nUser Guide\n!",
        "children": [
          {
            "heading": "Usage",
            "text": "You can either download binaries from the\nlatest release\nor install it with pip:\npip install maturin\nThere are four main commands:\nmaturin new\ncreates a new cargo project with maturin configured.\nmaturin publish\nbuilds the crate into python packages and publishes them to pypi.\nmaturin build\nbuilds the wheels and stores them in a folder (\ntarget/wheels\nby default), but doesn't upload them. It's possible to upload those with\ntwine\nor\nmaturin upload\n.\nmaturin develop\nbuilds the crate and installs it as a python module directly in the current virtualenv. Note that while\nmaturin develop\nis faster, it doesn't support all the feature that running\npip install\nafter\nmaturin build\nsupports.\npyo3\nand\nrust-cpython\nbindings are automatically detected. For cffi or binaries, you need to pass\n-b cffi\nor\n-b bin\n.\nmaturin doesn't need extra configuration files and doesn't clash with an existing setuptools-rust or milksnake configuration.\nYou can even integrate it with testing tools such as\ntox\n.\nThere are examples for the different bindings in the\ntest-crates\nfolder.\nThe name of the package will be the name of the cargo project, i.e. the name field in the\n[package]\nsection of\nCargo.toml\n.\nThe name of the module, which you are using when importing, will be the\nname\nvalue in the\n[lib]\nsection (which defaults to the name of the package). For binaries, it's simply the name of the binary generated by cargo.",
            "children": []
          },
          {
            "heading": "Python packaging basics",
            "text": "Python packages come in two formats:\nA built form called wheel and source distributions (sdist), both of which are archives.\nA wheel can be compatible with any python version, interpreter (cpython and pypy, mainly), operating system and hardware architecture (for pure python wheels),\ncan be limited to a specific platform and architecture (e.g. when using ctypes or cffi) or to a specific python interpreter and version on a specific architecture and operating system (e.g. with pyo3 and rust-cpython).\nWhen using\npip install\non a package, pip tries to find a matching wheel and install that. If it doesn't find one, it downloads the source distribution and builds a wheel for the current platform,\nwhich requires the right compilers to be installed. Installing a wheel is much faster than installing a source distribution as building wheels is generally slow.\nWhen you publish a package to be installable with\npip install\n, you upload it to\npypi\n, the official package repository.\nFor testing, you can use\ntest pypi\ninstead, which you can use with\npip install --index-url https://test.pypi.org/simple/\n.\nNote that for publishing for linux,\nyou need to use the manylinux docker container\n, while for publishing from your repository you can use the\nPyO3/maturin-action github action\n.",
            "children": []
          },
          {
            "heading": "pyo3 and rust-cpython",
            "text": "For pyo3 and rust-cpython, maturin can only build packages for installed python versions. On linux and mac, all python versions in\nPATH\nare used.\nIf you don't set your own interpreters with\n-i\n, a heuristic is used to search for python installations.\nOn windows all versions from the python launcher (which is installed by default by the python.org installer) and all conda environments except base are used. You can check which versions are picked up with the\nlist-python\nsubcommand.\npyo3 will set the used python interpreter in the environment variable\nPYTHON_SYS_EXECUTABLE\n, which can be used from custom build scripts. Maturin can build and upload wheels for pypy with pyo3, even though only pypy3.7-7.3 on linux is tested.",
            "children": []
          },
          {
            "heading": "Cffi",
            "text": "Cffi wheels are compatible with all python versions including pypy. If\ncffi\nisn't installed and python is running inside a virtualenv, maturin will install it, otherwise you have to install it yourself (\npip install cffi\n).\nmaturin uses cbindgen to generate a header file, which can be customized by configuring cbindgen through a\ncbindgen.toml\nfile inside your project root. Alternatively you can use a build script that writes a header file to\n$PROJECT_ROOT/target/header.h\n.\nBased on the header file maturin generates a module which exports an\nffi\nand a\nlib\nobject.",
            "children": []
          },
          {
            "heading": "uniffi",
            "text": "uniffi bindings use\nuniffi-rs\nto generate Python\nctypes\nbindings\nfrom an interface definition file. uniffi wheels are compatible with all python versions including pypy.",
            "children": []
          },
          {
            "heading": "Mixed rust/python projects",
            "text": "To create a mixed rust/python project, create a folder with your module name (i.e.\nlib.name\nin Cargo.toml) next to your Cargo.toml and add your python sources there:\nmy-project\n├── Cargo.toml\n├── my_project\n│   ├── __init__.py\n│   └── bar.py\n├── pyproject.toml\n├── README.md\n└── src\n    └── lib.rs\nYou can specify a different python source directory in\npyproject.toml\nby setting\ntool.maturin.python-source\n, for example\npyproject.toml\n[\ntool\n.\nmaturin\n]\npython-source\n=\n\"\npython\n\"\nthen the project structure would look like this:\nmy-project\n├── Cargo.toml\n├── python\n│   └── my_project\n│       ├── __init__.py\n│       └── bar.py\n├── pyproject.toml\n├── README.md\n└── src\n    └── lib.rs\nNote\nThis structure is recommended to avoid\na common\nImportError\npitfall\nmaturin will add the native extension as a module in your python folder. When using develop, maturin will copy the native library and for cffi also the glue code to your python folder. You should add those files to your gitignore.\nWith cffi you can do\nfrom .my_project import lib\nand then use\nlib.my_native_function\n, with pyo3/rust-cpython you can directly\nfrom .my_project import my_native_function\n.\nExample layout with pyo3 after\nmaturin develop\n:\nmy-project\n├── Cargo.toml\n├── my_project\n│   ├── __init__.py\n│   ├── bar.py\n│   └── my_project.cpython-36m-x86_64-linux-gnu.so\n├── README.md\n└── src\n    └── lib.rs",
            "children": []
          },
          {
            "heading": "Python metadata",
            "text": "maturin supports\nPEP 621\n, you can specify python package metadata in\npyproject.toml\n.\nmaturin merges metadata from\nCargo.toml\nand\npyproject.toml\n,\npyproject.toml\ntake precedence over\nCargo.toml\n.\nTo specify python dependencies, add a list\ndependencies\nin a\n[project]\nsection in the\npyproject.toml\n. This list is equivalent to\ninstall_requires\nin setuptools:\n[\nproject\n]\nname\n=\n\"\nmy-project\n\"\ndependencies\n= [\n\"\nflask~=1.1.0\n\"\n,\n\"\ntoml==0.10.0\n\"\n]\nPip allows adding so called console scripts, which are shell commands that execute some function in you program. You can add console scripts in a section\n[project.scripts]\n.\nThe keys are the script names while the values are the path to the function in the format\nsome.module.path:class.function\n, where the\nclass\npart is optional. The function is called with no arguments. Example:\n[\nproject\n.\nscripts\n]\nget_42\n=\n\"\nmy_project:DummyClass.get_42\n\"\nYou can also specify\ntrove classifiers\nin your Cargo.toml under\nproject.classifiers\n:\n[\nproject\n]\nname\n=\n\"\nmy-project\n\"\nclassifiers\n= [\n\"\nProgramming Language :: Python\n\"\n]",
            "children": []
          },
          {
            "heading": "Source distribution",
            "text": "maturin supports building through\npyproject.toml\n. To use it, create a\npyproject.toml\nnext to your\nCargo.toml\nwith the following content:\n[\nbuild-system\n]\nrequires\n= [\n\"\nmaturin>=0.14,<0.15\n\"\n]\nbuild-backend\n=\n\"\nmaturin\n\"\nIf a\npyproject.toml\nwith a\n[build-system]\nentry is present, maturin can build a source distribution of your package when\n--sdist\nis specified.\nThe source distribution will contain the same files as\ncargo package\n. To only build a source distribution, pass\n--interpreter\nwithout any values.\nYou can then e.g. install your package with\npip install .\n. With\npip install . -v\nyou can see the output of cargo and maturin.\nYou can use the options\ncompatibility\n,\nskip-auditwheel\n,\nbindings\n,\nstrip\nand common Cargo build options such as\nfeatures\nunder\n[tool.maturin]\nthe same way you would when running maturin directly.\nThe\nbindings\nkey is required for cffi and bin projects as those can't be automatically detected. Currently, all builds are in release mode (see\nthis thread\nfor details).\nFor a non-manylinux build with cffi bindings you could use the following:\n[\nbuild-system\n]\nrequires\n= [\n\"\nmaturin>=0.14,<0.15\n\"\n]\nbuild-backend\n=\n\"\nmaturin\n\"\n[\ntool\n.\nmaturin\n]\nbindings\n=\n\"\ncffi\n\"\ncompatibility\n=\n\"\nlinux\n\"\nmanylinux\noption is also accepted as an alias of\ncompatibility\nfor backward compatibility with old version of maturin.\nTo include arbitrary files in the sdist for use during compilation specify\ninclude\nas an array of\npath\nglobs with\nformat\nset to\nsdist\n:\n[\ntool\n.\nmaturin\n]\ninclude\n= [{\npath\n=\n\"\npath/**/*\n\"\n,\nformat\n=\n\"\nsdist\n\"\n}]\nThere's a\nmaturin sdist\ncommand for only building a source distribution as workaround for\npypa/pip#6041\n.",
            "children": []
          },
          {
            "heading": "Manylinux and auditwheel",
            "text": "For portability reasons, native python modules on linux must only dynamically link a set of very few libraries which are installed basically everywhere, hence the name manylinux.\nThe pypa offers special docker images and a tool called\nauditwheel\nto ensure compliance with the\nmanylinux rules\n.\nIf you want to publish widely usable wheels for linux pypi,\nyou need to use a manylinux docker image\n.\nThe Rust compiler since version 1.64\nrequires at least glibc 2.17\n, so you need to use at least manylinux2014.\nFor publishing, we recommend enforcing the same manylinux version as the image with the manylinux flag, e.g. use\n--manylinux 2014\nif you are building in\nquay.io/pypa/manylinux2014_x86_64\n.\nThe\nPyO3/maturin-action\ngithub action already takes care of this if you set e.g.\nmanylinux: 2014\n.\nmaturin contains a reimplementation of auditwheel automatically checks the generated library and gives the wheel the proper.\nIf your system's glibc is too new or you link other shared libraries, it will assign the\nlinux\ntag.\nYou can also manually disable those checks and directly use native linux target with\n--manylinux off\n.\nFor full manylinux compliance you need to compile in a CentOS docker container. The\npyo3/maturin\nimage is based on the manylinux2014 image,\nand passes arguments to the\nmaturin\nbinary. You can use it like this:\ndocker run --rm -v $(pwd):/io ghcr.io/pyo3/maturin build --release  # or other maturin arguments\nNote that this image is very basic and only contains python, maturin and stable rust. If you need additional tools, you can run commands inside the manylinux container.\nSee\nkonstin/complex-manylinux-maturin-docker\nfor a small educational example or\nnanoporetech/fast-ctc-decode\nfor a real world setup.\nmaturin itself is manylinux compliant when compiled for the musl target.",
            "children": []
          },
          {
            "heading": "Examples",
            "text": "ballista-python\n- A Python library that binds to Apache Arrow distributed query engine Ballista\nconnector-x\n- ConnectorX enables you to load data from databases into Python in the fastest and most memory efficient way\ndatafusion-python\n- a Python library that binds to Apache Arrow in-memory query engine DataFusion\ndeltalake-python\n- Native Delta Lake Python binding based on delta-rs with Pandas integration\norjson\n- A fast, correct JSON library for Python\npolars\n- Fast multi-threaded DataFrame library in Rust | Python | Node.js\npydantic-core\n- Core validation logic for pydantic written in Rust\npyrus-cramjam\n- Thin Python wrapper to de/compression algorithms in Rust\npyxel\n- A retro game engine for Python\nroapi\n- ROAPI automatically spins up read-only APIs for static datasets without requiring you to write a single line of code\nrobyn\n-  A fast and extensible async python web server with a Rust runtime\nruff\n- An extremely fast Python linter, written in Rust\ntantivy-py\n- Python bindings for Tantivy\nwatchfiles\n- Simple, modern and high performance file watching and code reload in python\nwonnx\n- Wonnx is a GPU-accelerated ONNX inference run-time written 100% in Rust",
            "children": []
          },
          {
            "heading": "Contributing",
            "text": "Everyone is welcomed to contribute to maturin! There are many ways to support the project, such as:\nhelp maturin users with issues on GitHub and Gitter\nimprove documentation\nwrite features and bugfixes\npublish blogs and examples of how to use maturin\nOur\ncontributing notes\nhave more resources if you wish to volunteer time for maturin and are searching where to start.\nIf you don't have time to contribute yourself but still wish to support the project's future success, some of our maintainers have GitHub sponsorship pages:\nmessense",
            "children": []
          },
          {
            "heading": "License",
            "text": "Licensed under either of:\nApache License, Version 2.0, (\nLICENSE-APACHE\nor\nhttp://www.apache.org/licenses/LICENSE-2.0\n)\nMIT license (\nLICENSE-MIT\nor\nhttp://opensource.org/licenses/MIT\n)\nat your option.",
            "children": []
          }
        ]
      }
    ]
  },
  "metadata": {
    "description": "Build and publish crates with pyo3, rust-cpython and cffi bindings as well as rust binaries as python packages",
    "license": null,
    "stars": 0,
    "forks": 0,
    "topics": [],
    "last_updated": "2023-03-17T00:54:15.000Z"
  }
}