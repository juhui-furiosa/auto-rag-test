{
  "name": "proptest",
  "url": "https://github.com/furiosa-ai/proptest",
  "visibility": "public",
  "readme": {
    "title": "Proptest",
    "sections": [
      {
        "heading": "Proptest",
        "text": "",
        "children": [
          {
            "heading": "Book",
            "text": "A detailed introduction to proptest can be found in the\nbook",
            "children": []
          },
          {
            "heading": "Introduction",
            "text": "Proptest is a property testing framework (i.e., the QuickCheck family)\ninspired by the\nHypothesis\nframework for\nPython. It allows to test that certain properties of your code hold for\narbitrary inputs, and if a failure is found, automatically finds the\nminimal test case to reproduce the problem. Unlike QuickCheck, generation\nand shrinking is defined on a per-value basis instead of per-type, which\nmakes it more flexible and simplifies composition.",
            "children": [
              {
                "heading": "Status of this crate",
                "text": "The crate is fairly close to being feature-complete and has not seen\nsubstantial architectural changes in quite some time. At this point, it mainly\nsees passive maintenance.\nSee the\nchangelog\nfor a full list of substantial historical changes, breaking and otherwise.",
                "children": []
              },
              {
                "heading": "MSRV",
                "text": "The current MSRV of this crate is 1.60.\nThe MSRV is guaranteed to not exceeed\n<current stable release> - 7\n, though in practice it may be lower than this - your mileage may vary.\nIf we change this policy in a backwards incompatible way (e.g. changing it to\n<current stable release> - 1\n), this constitutes a breaking change, and would be a major version bump (e.g. 1.1 -> 2.0).",
                "children": []
              },
              {
                "heading": "What is property testing?",
                "text": "Property testing\nis a system of testing code by checking that certain\nproperties of its output or behaviour are fulfilled for all inputs. These\ninputs are generated automatically, and, critically, when a failing input\nis found, the input is automatically reduced to a\nminimal\ntest case.\nProperty testing is best used to complement traditional unit testing (i.e.,\nusing specific inputs chosen by hand). Traditional tests can test specific\nknown edge cases, simple inputs, and inputs that were known in the past to\nreveal bugs, whereas property tests will search for more complicated inputs\nthat cause problems.",
                "children": []
              }
            ]
          },
          {
            "heading": "Getting Started",
            "text": "Let's say we want to make a function that parses dates of the form\nYYYY-MM-DD\n. We're not going to worry about\nvalidating\nthe date, any\ntriple of integers is fine. So let's bang something out real quick.\nfn\nparse_date\n(\ns\n:\n&\nstr\n)\n->\nOption\n<\n(\nu32\n,\nu32\n,\nu32\n)\n>\n{\nif\n10\n!= s\n.\nlen\n(\n)\n{\nreturn\nNone\n;\n}\nif\n\"-\"\n!=\n&\ns\n[\n4\n..\n5\n]\n||\n\"-\"\n!=\n&\ns\n[\n7\n..\n8\n]\n{\nreturn\nNone\n;\n}\nlet\nyear =\n&\ns\n[\n0\n..\n4\n]\n;\nlet\nmonth =\n&\ns\n[\n6\n..\n7\n]\n;\nlet\nday =\n&\ns\n[\n8\n..\n10\n]\n;\nyear\n.\nparse\n::\n<\nu32\n>\n(\n)\n.\nok\n(\n)\n.\nand_then\n(\n|y| month\n.\nparse\n::\n<\nu32\n>\n(\n)\n.\nok\n(\n)\n.\nand_then\n(\n|m| day\n.\nparse\n::\n<\nu32\n>\n(\n)\n.\nok\n(\n)\n.\nmap\n(\n|d|\n(\ny\n,\nm\n,\nd\n)\n)\n)\n)\n}\nIt compiles, that means it works, right? Maybe not, let's add some tests.\n#\n[\ntest\n]\nfn\ntest_parse_date\n(\n)\n{\nassert_eq\n!\n(\nNone\n,\nparse_date\n(\n\"2017-06-1\"\n)\n)\n;\nassert_eq\n!\n(\nNone\n,\nparse_date\n(\n\"2017-06-170\"\n)\n)\n;\nassert_eq\n!\n(\nNone\n,\nparse_date\n(\n\"2017006-17\"\n)\n)\n;\nassert_eq\n!\n(\nNone\n,\nparse_date\n(\n\"2017-06017\"\n)\n)\n;\nassert_eq\n!\n(\nSome\n(\n(\n2017\n,\n06\n,\n17\n)\n)\n,\nparse_date\n(\n\"2017-06-17\"\n)\n)\n;\n}\nTests pass, deploy to production! But now your application starts crashing,\nand people are upset that you moved Christmas to February. Maybe we need to\nbe a bit more thorough.\nIn\nCargo.toml\n, add\n[\ndev-dependencies\n]\nproptest\n=\n\"\n1.0.0\n\"\nNow we can add some property tests to our date parser. But how do we test\nthe date parser for arbitrary inputs, without making another date parser in\nthe test to validate it? We won't need to as long as we choose our inputs\nand properties correctly. But before correctness, there's actually an even\nsimpler property to test:\nThe function should not crash.\nLet's start\nthere.\n// Bring the macros and other important things into scope.\nuse\nproptest\n::\nprelude\n::\n*\n;\nproptest\n!\n{\n#\n[\ntest\n]\nfn\ndoesnt_crash\n(\ns in\n\"\n\\\\\nPC*\"\n)\n{\nparse_date\n(\n&\ns\n)\n;\n}\n}\nWhat this does is take a literally random\n&String\n(ignore\n\\\\PC*\nfor the\nmoment, we'll get back to that — if you've already figured it out, contain\nyour excitement for a bit) and give it to\nparse_date()\nand then throw the\noutput away.\nWhen we run this, we get a bunch of scary-looking output, eventually ending\nwith\nthread 'main' panicked at 'Test failed: byte index 4 is not a char boundary; it is inside 'ௗ' (bytes 2..5) of `aAௗ0㌀0`; minimal failing input: s = \"aAௗ0㌀0\"\n\tsuccesses: 102\n\tlocal rejects: 0\n\tglobal rejects: 0\n'\nIf we look at the top directory after the test fails, we'll see a new\nproptest-regressions\ndirectory, which contains some files corresponding to\nsource files containing failing test cases. These are\nfailure\npersistence\nfiles. The first thing we should do is add these to source control.\n$ git add proptest-regressions\nThe next thing we should do is copy the failing case to a traditional unit\ntest since it has exposed a bug not similar to what we've tested in the\npast.\n#\n[\ntest\n]\nfn\ntest_unicode_gibberish\n(\n)\n{\nassert_eq\n!\n(\nNone\n,\nparse_date\n(\n\"aAௗ0㌀0\"\n)\n)\n;\n}\nNow, let's see what happened... we forgot about UTF-8! You can't just\nblindly slice strings since you could split a character, in this case that\nTamil diacritic placed atop other characters in the string.\nIn the interest of making the code changes as small as possible, we'll just\ncheck that the string is ASCII and reject anything that isn't.\nfn\nparse_date\n(\ns\n:\n&\nstr\n)\n->\nOption\n<\n(\nu32\n,\nu32\n,\nu32\n)\n>\n{\nif\n10\n!= s\n.\nlen\n(\n)\n{\nreturn\nNone\n;\n}\n// NEW: Ignore non-ASCII strings so we don't need to deal with Unicode.\nif\n!s\n.\nis_ascii\n(\n)\n{\nreturn\nNone\n;\n}\nif\n\"-\"\n!=\n&\ns\n[\n4\n..\n5\n]\n||\n\"-\"\n!=\n&\ns\n[\n7\n..\n8\n]\n{\nreturn\nNone\n;\n}\nlet\nyear =\n&\ns\n[\n0\n..\n4\n]\n;\nlet\nmonth =\n&\ns\n[\n6\n..\n7\n]\n;\nlet\nday =\n&\ns\n[\n8\n..\n10\n]\n;\nyear\n.\nparse\n::\n<\nu32\n>\n(\n)\n.\nok\n(\n)\n.\nand_then\n(\n|y| month\n.\nparse\n::\n<\nu32\n>\n(\n)\n.\nok\n(\n)\n.\nand_then\n(\n|m| day\n.\nparse\n::\n<\nu32\n>\n(\n)\n.\nok\n(\n)\n.\nmap\n(\n|d|\n(\ny\n,\nm\n,\nd\n)\n)\n)\n)\n}\nThe tests pass now! But we know there are still more problems, so let's\ntest more properties.\nAnother property we want from our code is that it parses every valid date.\nWe can add another test to the\nproptest!\nsection:\nproptest\n!\n{\n// snip...\n#\n[\ntest\n]\nfn\nparses_all_valid_dates\n(\ns in\n\"[0-9]{4}-[0-9]{2}-[0-9]{2}\"\n)\n{\nparse_date\n(\n&\ns\n)\n.\nunwrap\n(\n)\n;\n}\n}\nThe thing to the right-hand side of\nin\nis actually a\nregular\nexpression\n, and\ns\nis chosen from strings which match it. So in our\nprevious test,\n\"\\\\PC*\"\nwas generating arbitrary strings composed of\narbitrary non-control characters. Now, we generate things in the YYYY-MM-DD\nformat.\nThe new test passes, so let's move on to something else.\nThe final property we want to check is that the dates are actually parsed\ncorrectly\n. Now, we can't do this by generating strings — we'd end up just\nreimplementing the date parser in the test! Instead, we start from the\nexpected output, generate the string, and check that it gets parsed back.\nproptest\n!\n{\n// snip...\n#\n[\ntest\n]\nfn\nparses_date_back_to_original\n(\ny in\n0u32\n..\n10000\n,\nm in\n1u32\n..\n13\n,\nd in\n1u32\n..\n32\n)\n{\nlet\n(\ny2\n,\nm2\n,\nd2\n)\n= parse_date\n(\n&\nformat!\n(\n\"{:04}-{:02}-{:02}\"\n,\ny\n,\nm\n,\nd\n)\n)\n.\nunwrap\n(\n)\n;\n// prop_assert_eq! is basically the same as assert_eq!, but doesn't\n// cause a bunch of panic messages to be printed on intermediate\n// test failures. Which one to use is largely a matter of taste.\nprop_assert_eq!\n(\n(\ny\n,\nm\n,\nd\n)\n,\n(\ny2\n,\nm2\n,\nd2\n)\n)\n;\n}\n}\nHere, we see that besides regexes, we can use any expression which is a\nproptest::strategy::Strategy\n, in this case, integer ranges.\nThe test fails when we run it. Though there's not much output this time.\nthread 'main' panicked at 'Test failed: assertion failed: `(left == right)` (left: `(0, 10, 1)`, right: `(0, 0, 1)`) at examples/dateparser_v2.rs:46; minimal failing input: y = 0, m = 10, d = 1\n\tsuccesses: 2\n\tlocal rejects: 0\n\tglobal rejects: 0\n', examples/dateparser_v2.rs:33\nnote: Run with `RUST_BACKTRACE=1` for a backtrace.\nThe failing input is\n(y, m, d) = (0, 10, 1)\n, which is a rather specific\noutput. Before thinking about why this breaks the code, let's look at what\nproptest did to arrive at this value. At the start of our test function,\ninsert\nprintln\n!\n(\n\"y = {}, m = {}, d = {}\"\n,\ny\n,\nm\n,\nd\n)\n;\nRunning the test again, we get something like this:\ny = 2497, m = 8, d = 27\ny = 9641, m = 8, d = 18\ny = 7360, m = 12, d = 20\ny = 3680, m = 12, d = 20\ny = 1840, m = 12, d = 20\ny = 920, m = 12, d = 20\ny = 460, m = 12, d = 20\ny = 230, m = 12, d = 20\ny = 115, m = 12, d = 20\ny = 57, m = 12, d = 20\ny = 28, m = 12, d = 20\ny = 14, m = 12, d = 20\ny = 7, m = 12, d = 20\ny = 3, m = 12, d = 20\ny = 1, m = 12, d = 20\ny = 0, m = 12, d = 20\ny = 0, m = 6, d = 20\ny = 0, m = 9, d = 20\ny = 0, m = 11, d = 20\ny = 0, m = 10, d = 20\ny = 0, m = 10, d = 10\ny = 0, m = 10, d = 5\ny = 0, m = 10, d = 3\ny = 0, m = 10, d = 2\ny = 0, m = 10, d = 1\nThe test failure message said there were two successful cases; we see these\nat the very top,\n2497-08-27\nand\n9641-08-18\n. The next case,\n7360-12-20\n, failed. There's nothing immediately obviously special about\nthis date. Fortunately, proptest reduced it to a much simpler case. First,\nit rapidly reduced the\ny\ninput to\n0\nat the beginning, and similarly\nreduced the\nd\ninput to the minimum allowable value of\n1\nat the end.\nBetween those two, though, we see something different: it tried to shrink\n12\nto\n6\n, but then ended up raising it back up to\n10\n. This is because\nthe\n0000-06-20\nand\n0000-09-20\ntest cases\npassed\n.\nIn the end, we get the date\n0000-10-01\n, which apparently gets parsed as\n0000-00-01\n. Again, this failing case was added to the failure persistence\nfile, and we should add this as its own unit test:\n$ git add proptest-regressions\n#\n[\ntest\n]\nfn\ntest_october_first\n(\n)\n{\nassert_eq\n!\n(\nSome\n(\n(\n0\n,\n10\n,\n1\n)\n)\n,\nparse_date\n(\n\"0000-10-01\"\n)\n)\n;\n}\nNow to figure out what's broken in the code. Even without the intermediate\ninput, we can say with reasonable confidence that the year and day parts\ndon't come into the picture since both were reduced to the minimum\nallowable input. The month input was\nnot\n, but was reduced to\n10\n. This\nmeans we can infer that there's something special about\n10\nthat doesn't\nhold for\n9\n. In this case, that \"special something\" is being two digits\nwide. In our code:\nlet\nmonth =\n&\ns\n[\n6\n..\n7\n]\n;\nWe were off by one, and need to use the range\n5..7\n. After fixing this,\nthe test passes.\nThe\nproptest!\nmacro has some additional syntax, including for setting\nconfiguration for things like the number of test cases to generate. See its\ndocumentation\nfor more details.",
            "children": []
          },
          {
            "heading": "Differences between QuickCheck and Proptest",
            "text": "QuickCheck and Proptest are similar in many ways: both generate random\ninputs for a function to check certain properties, and automatically shrink\ninputs to minimal failing cases.\nThe one big difference is that QuickCheck generates and shrinks values\nbased on type alone, whereas Proptest uses explicit\nStrategy\nobjects. The\nQuickCheck approach has a lot of disadvantages in comparison:\nQuickCheck can only define one generator and shrinker per type. If you need a\ncustom generation strategy, you need to wrap it in a newtype and implement\ntraits on that by hand. In Proptest, you can define arbitrarily many\ndifferent strategies for the same type, and there are plenty built-in.\nFor the same reason, QuickCheck has a single \"size\" configuration that tries\nto define the range of values generated. If you need an integer between 0 and\n100 and another between 0 and 1000, you probably need to do another newtype.\nIn Proptest, you can directly just express that you want a\n0..100\ninteger\nand a\n0..1000\ninteger.\nTypes in QuickCheck are not easily composable. Defining\nArbitrary\nand\nShrink\nfor a new struct which is simply produced by the composition of its\nfields requires implementing both by hand, including a bidirectional mapping\nbetween the struct and a tuple of its fields. In Proptest, you can make a\ntuple of the desired components and then\nprop_map\nit into the desired form.\nShrinking happens automatically in terms of the input types.\nBecause constraints on values cannot be expressed in QuickCheck, generation\nand shrinking may lead to a lot of input rejections. Strategies in Proptest\nare aware of simple constraints and do not generate or shrink to values that\nviolate them.\nThe author of Hypothesis also has an\narticle on this\ntopic\n.\nOf course, there's also some relative downsides that fall out of what\nProptest does differently:\nGenerating complex values in Proptest can be up to an order of magnitude\nslower than in QuickCheck. This is because QuickCheck performs stateless\nshrinking based on the output value, whereas Proptest must hold on to all the\nintermediate states and relationships in order for its richer shrinking model\nto work.",
            "children": []
          },
          {
            "heading": "Limitations of Property Testing",
            "text": "Given infinite time, property testing will eventually explore the whole\ninput space to a test. However, time is not infinite, so only a randomly\nsampled portion of the input space can be explored. This means that\nproperty testing is extremely unlikely to find single-value edge cases in a\nlarge space. For example, the following test will virtually always pass:\nuse\nproptest\n::\nprelude\n::\n*\n;\nproptest\n!\n{\n#\n[\ntest\n]\nfn\ni64_abs_is_never_negative\n(\na\n:\ni64\n)\n{\n// This actually fails if a == i64::MIN, but randomly picking one\n// specific value out of 2⁶⁴ is overwhelmingly unlikely.\nassert!\n(\na\n.\nabs\n(\n)\n>=\n0\n)\n;\n}\n}\nBecause of this, traditional unit testing with intelligently selected cases\nis still necessary for many kinds of problems.\nSimilarly, in some cases it can be hard or impossible to define a strategy\nwhich actually produces useful inputs. A strategy of\n.{1,4096}\nmay be\ngreat to fuzz a C parser, but is highly unlikely to produce anything that\nmakes it to a code generator.",
            "children": []
          }
        ]
      },
      {
        "heading": "Acknowledgements",
        "text": "This crate wouldn't have come into existence had it not been for the\nRust port\nof QuickCheck\nand the\nregex_generate\ncrate which\ngave wonderful examples of what is possible.",
        "children": [
          {
            "heading": "Contribution",
            "text": "Unless you explicitly state otherwise, any contribution intentionally submitted\nfor inclusion in the work by you, as defined in the Apache-2.0 license, shall\nbe dual licensed as above, without any additional terms or conditions.",
            "children": []
          }
        ]
      }
    ]
  },
  "metadata": {
    "description": "Hypothesis-like property testing for Rust",
    "license": null,
    "stars": 0,
    "forks": 0,
    "topics": [],
    "last_updated": "2025-11-14T00:40:53.768620Z"
  }
}